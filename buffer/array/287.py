"""Find the Duplicate Number
"""


def findDuplicate(nums):
    '''Slow and Fast Pointer
    -------------------------
    Usage: to find the loop in linked list 查找链表上是否有环
    
    1. 为啥有重复数字则链表中有环？
    由于有重复数字，所以单项链表上一定不能向一个方向发展。
    比如说1->2->3，如果现在出现重复数字，那么第四项一定会发展出一个往回的方向，从而形成一个环
    
    2. 为啥快慢指针能够发现链表中的环？
    这个问题你可以用数学归纳法来思考。首先由于链表是一个环，所以相遇的过程可以看作是快指针从后面追赶慢指针过程
        1. 快指针与慢指针之间差一步。此时继续往后走，慢指针前进一步，快指针前进两步，两者相遇
        2. 快指针与慢指针之间差两步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间差一步，转换成第一种情况
        3. 快指针与慢指针之间差N步。此时继续往后走，慢指针前进一步，快指针前进两步，两者之间相差(N+1-2)==N-1步
    因此，此题得证。所以快指针必然与慢指针相遇。又因为快指针的速度是慢指针速度的两倍，所以相遇的时候必然只绕了一圈
    
    3. 快慢指针相交之后，为啥让第三枚指针从头开始？
        1. 慢指针每次只走一步，快指针每次走两步
        2. 慢指针走了n步之后，与快指针相遇，快指针在相遇的时候应该走了2n步
        3. 现在快慢指针应该是重合了，但是快指针应该比慢指针多绕了i圈，假设环的周长是c，所以 (2n - n) % c == 0
        4. 假设从起始点到环的开始点的距离为m，即从起始点走m步就能遇到闭环，在快慢指针重合的时候，慢指针应该在环上走了n - m步
        5. 在重合的时候，让第三个指针开始移动从起始点，当第三枚指针走到环的起始处，即重复数字所在的地方，已经过了m步，
        慢指针在环上走的步数应该是 n - m + m = n，所以此时，慢指针已经回到了环的起始处，即重复数字所在的地方，并且与第三枚指针重合

    解题思路：
    将这些数字想成链表上的节点，数组中的数字代表了下一个节点的数组下标。找重复的数字就是找链表中成环的那个点。由于题目保证了一定会有重复
    的数字，所以一定会成环。所以用快慢指针的方式。快指针一次走2步，慢指针一次走1步，相交之后，让第三枚指针重头开始，每次只走一步，再次
    遇见的时候就是成环的交点处，也即是重复数字所在的地方。
    '''
    slow = nums[0]
    fast = nums[nums[0]]

    while fast != slow:
        slow = nums[slow]
        fast = nums[nums[fast]]
    walker = 0
    while walker != slow:
        walker = nums[walker]
        slow = nums[slow]
    return walker


if __name__ == "__main__":
    a = [1, 3, 4, 2, 1]
    print(findDuplicate(a))